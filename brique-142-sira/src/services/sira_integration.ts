/**
 * BRIQUE 142-SIRA â€” SIRA Integration Service
 * Node wrapper to call Python gRPC SIRA model service via HTTP bridge
 */

import fetch from 'node-fetch';
import { pool } from '../db';

/**
 * Call SIRA model for inference
 * Returns prediction, justification, model metadata
 */
export async function callSiraModel(samples: any[], requestId?: string) {
  const url = process.env.SIRA_BRIDGE_URL || 'http://localhost:8081';

  try {
    const resp = await fetch(`${url}/v1/infer`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Idempotency-Key': requestId || '',
      },
      body: JSON.stringify({ samples }),
      timeout: 30000, // 30s timeout
    });

    if (!resp.ok) {
      throw new Error(`sira_bridge_error: ${resp.status} ${resp.statusText}`);
    }

    const result = await resp.json();

    // Log model run for audit
    await logModelRun(result);

    return result;
  } catch (error: any) {
    console.error('[SIRA Integration] Error calling model:', error);
    throw new Error(`sira_model_call_failed: ${error.message}`);
  }
}

/**
 * Log SIRA model run for audit trail
 */
async function logModelRun(result: any) {
  try {
    await pool.query(
      `INSERT INTO sira_model_runs(model_version, dataset_hash, metrics, artifacts, triggered_by)
       VALUES ($1, $2, $3, $4, $5)`,
      [
        result.model_version || 'unknown',
        result.dataset_hash || null,
        result.metrics || {},
        { debug_info: result.debug_info },
        'api_call',
      ]
    );
  } catch (err) {
    console.error('[SIRA Integration] Failed to log model run:', err);
    // Don't fail the request if logging fails
  }
}

/**
 * Generate suggested playbook from event samples
 */
export async function generateSuggestedPlaybook(samples: any[], requestId?: string) {
  const modelResult = await callSiraModel(samples, requestId);

  // Convert model output to suggested playbook format
  const suggestion = {
    scenario: modelResult.scenario || 'unknown_scenario',
    confidence: Number(modelResult.confidence || 0),
    justification: {
      top_features: modelResult.justification || [],
      model_version: modelResult.model_version,
      dataset_hash: modelResult.dataset_hash,
    },
    proposed_actions: (modelResult.suggested_actions || []).map((action: string) =>
      parseActionString(action)
    ),
    metadata: {
      sample_count: samples.length,
      model_version: modelResult.model_version,
      request_id: requestId,
    },
  };

  return suggestion;
}

/**
 * Parse action string from model to structured action object
 * Example: "freeze_accounts:dry_run" -> {action: "freeze_accounts", params: {dry_run: true}}
 */
function parseActionString(actionStr: string): any {
  const parts = actionStr.split(':');
  const action = parts[0];
  const params: any = {};

  // Parse simple params
  for (let i = 1; i < parts.length; i++) {
    const param = parts[i];
    if (param === 'dry_run') params.dry_run = true;
    else if (param.startsWith('severity=')) params.severity = param.split('=')[1];
    else if (param.startsWith('reason=')) params.reason = param.split('=')[1];
  }

  return { action, params };
}

/**
 * Persist suggested playbook to database
 */
export async function persistSuggestedPlaybook(
  suggestion: any,
  sampleEvents: any[]
): Promise<any> {
  const { rows } = await pool.query(
    `INSERT INTO suggested_playbooks (scenario, confidence, justification, proposed_actions, metadata)
     VALUES ($1, $2, $3, $4, $5) RETURNING *`,
    [
      suggestion.scenario,
      suggestion.confidence,
      suggestion.justification,
      JSON.stringify(suggestion.proposed_actions),
      suggestion.metadata || {},
    ]
  );

  const suggestionId = rows[0].id;

  // Store sample events (limit to 10)
  for (const sample of sampleEvents.slice(0, 10)) {
    await pool.query(
      `INSERT INTO suggested_playbook_examples (suggested_playbook_id, event_sample)
       VALUES ($1, $2)`,
      [suggestionId, sample]
    );
  }

  return rows[0];
}

/**
 * Create actual playbook from approved suggestion
 */
export async function createPlaybookFromSuggestion(
  suggestion: any,
  approverId: string
): Promise<any> {
  const name = `SIRA: ${suggestion.scenario}`;
  const description = `Auto-generated by SIRA (confidence=${suggestion.confidence})`;
  const triggers = { scenario: suggestion.scenario };
  const actions = suggestion.proposed_actions;

  const { rows } = await pool.query(
    `INSERT INTO playbooks (name, description, triggers, actions, created_by, active)
     VALUES ($1, $2, $3, $4, $5, $6) RETURNING *`,
    [name, description, triggers, JSON.stringify(actions), approverId, false]
  );

  return rows[0];
}
